/**
* Hub Miner: a hubness-aware machine learning experimentation library.
* Copyright (C) 2014  Nenad Tomasev. Email: nenad.tomasev at gmail.com
* 
* This program is free software: you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation, either version 3 of the License, or (at your option) any later
* version.
* 
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License along with
* this program. If not, see <http://www.gnu.org/licenses/>.
*/
package data.neighbors.approximate.test;

import data.neighbors.NeighborSetFinder;
import data.neighbors.approximate.AppKNNGraphLanczosBisection;
import data.representation.DataSet;
import distances.primary.CombinedMetric;
import ioformat.FileUtil;
import ioformat.SupervisedLoader;
import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;
import util.CommandLineParser;

/**
 * This script lets the user manually inspect the quality of the kNN sets
 * generated by the approximate method via Lanczos bisections, by comparing the
 * approximate to the actual kNN sets.
 *
 * @author Nenad Tomasev <nenad.tomasev at gmail.com>
 */
public class AppKNNLanczosBisectionEval {

    /**
     * This method runs the script that compares the approximate kNN
     * implementation with the exact implementation by allowing for manual (or
     * automatic) comparisons of the generated kNN sets.
     *
     * @param args Command line parameters, as specified.
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        // Input definitions.
        CommandLineParser clp = new CommandLineParser(true);
        clp.addParam("-inFile", "Path to the data file.",
                CommandLineParser.STRING, true, false);
        clp.addParam("-outFile", "Path to the output file.",
                CommandLineParser.STRING, true, false);
        clp.addParam("-k", "Neighborhood size.",
                CommandLineParser.INTEGER, true, false);
        clp.addParam("-alpha", "Approximate kNN set quality parameter.",
                CommandLineParser.FLOAT, true, false);
        // Input parsing.
        clp.parseLine(args);
        int k = (Integer) clp.getParamValues("-k").get(0);
        File outFile = new File((String) clp.getParamValues("-outFile").get(0));
        File dsFile = new File((String) clp.getParamValues("-inFile").get(0));
        float alpha = (Float) clp.getParamValues("-alpha").get(0);
        FileUtil.createFile(outFile);
        // Data load.
        DataSet dset = SupervisedLoader.loadData(dsFile, false);
        CombinedMetric cmet = CombinedMetric.FLOAT_MANHATTAN;
        dset.normalizeFloats();
        // Approximate kNN set calculations.
        AppKNNGraphLanczosBisection appNSF = new AppKNNGraphLanczosBisection(
                dset, cmet, k, alpha);
        System.out.println("Calculating app kNN sets.");
        appNSF.calculateApproximateNeighborSets();
        System.out.println("Calculated app kNN sets.");
        // Exact kNN set calculations.
        NeighborSetFinder nsf = new NeighborSetFinder(dset, cmet);
        nsf.calculateDistances();
        nsf.calculateNeighborSetsMultiThr(k, 8);
        // Print the kNN sets to a file.
        try (PrintWriter pw = new PrintWriter(new FileWriter(outFile));) {
            for (int i = 0; i < dset.size(); i++) {
                pw.print(" exact knns: ");
                for (int kInd = 0; kInd < k; kInd++) {
                    pw.print(nsf.getKNeighbors()[i][kInd]);
                    pw.print(" ");
                }
                pw.print(", app knns: ");
                for (int kInd = 0; kInd < k; kInd++) {
                    pw.print(appNSF.getKneighbors()[i][kInd]);
                    pw.print(" ");
                }
                pw.print(", dists (exact): ");
                for (int kInd = 0; kInd < k; kInd++) {
                    pw.print(nsf.getCombinedMetric().dist(
                            dset.data.get(i), dset.data.get(
                            nsf.getKNeighbors()[i][kInd])));
                    pw.print(" ");
                }
                pw.print(", dists (app): ");
                for (int kInd = 0; kInd < k; kInd++) {
                    pw.print(nsf.getCombinedMetric().dist(
                            dset.data.get(i), dset.data.get(
                            appNSF.getKneighbors()[i][kInd])));
                    pw.print(" ");
                }
                pw.println();
            }
        } catch (Exception e) {
            System.err.println(e.getMessage());
        }
    }
}
